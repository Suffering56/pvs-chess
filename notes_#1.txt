+ сделать CellsMatrix и CellDTO immutable;

- bot:
    + жадный режим
    + проверять что фигура которую рубишь дороже фигуры которую отдаешь
    + глубокий размен
    + защищать фигуры атакуемые игроком (если безвозмездное взятие/размен приведут к ухудшению ситуации для бота)
    + добавить ценность шаха и мата
    + позиционка: добавить желание развивать фигуры (AVAILABLE_MOVES_COUNT_DIFF + INVERTED)
    + вилка/связка/скрытый шах/мельница -> более глубокий анализ решает проблемы
    - база дебютов

+ оптимизировать MoveHelper в случае если будут проблемы с производительностью (полагаю скоро они появятся - когда бот начнет думать в глубину)
    + например сразу применять фильтры к доступным ходам - а не.. сначала находить их а потом удалять.
    + если король под шахом, то ходить можно только королем или фигурами которые могут заслонить от шаха/срубить шахуюущую

- глубокий анализ работает некорректно:
    - приоритет отдается ходу который может СЛУЧАЙНО (зависит от того как сходит игрок) к мату
        - такая работа некорректна и ведет к абсолютно глупым ходам.
    - другое дело если на каждый из ходов игрока бот может поставить мат... тогда да...
    - в общем предлагаю сначала создать MoveData (или аналог)
        - в него в отношении parent-children положим доступные ходы с текущим состояним матрицы, fakeGame, prevMove
            - далее уже ходить по этим ходам и вычислять рейтинги.



- подумать мб можно сделать piece enum-ом или каким-то иным способом решить проблему с бесконечным числом экземпляров одинаковых фигур
- добавить game.position() в extended_move;
- переключать флажок game.isUnderCheckSide/game.getLongPawnColumnIndex - после cellMatrix.executeMove():
    - мне кажется было бы неплохо если бы cellMatrix просто хранила эти параметры в себе, а от game можно было бы избавиться

- возможно стоит перейти на SESSION_SCOPE (несколько параллельных игр скорее всего поломают весь функционал если все останется на синглтонах):
- выложить в открытый доступ
- покрыть unit-тестами
- починить логгер в файл
